<?xml version="1.0" ?>
<!DOCTYPE TranscendenceExtension
[
	<!ENTITY BP_Logic					"0xD5125502">
	<!ENTITY bp_FactionCalculator		"0xD5125506">

	<!ENTITY bp_itPlasmidGunner			"0xD5125601">
	<!ENTITY bp_itMonoFilamentBlade		"0xD5125651">
]>

<TranscendenceExtension UNID="&BP_Logic;" version="1.0">

<Globals>
(block Nil
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Debug functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;; We'll start with some debug helpers, I have a feeling we'll need them
	;; borrowed from alterecco's DSF mod ;P

	;; This variable controls if we are running in debug or not.
	(setq bp_Debug True)
	;; this is a convenient way to force all debug calls from
	;; log to screen
	(setq bp_DebugToScreen Nil)
	;; DoDebug will print debug information if dsf_Debug
	;; is set. It takes a string which will be output, and
	;; if screen is True, it will be sent to the screen.
	;; Otherwise it will go into the log
	(setq bp_DoDebug (lambda (string screen)
		(if bp_Debug
			(if (or screen bp_DebugToScreen)
				(dbgOutput string)
				(dbgLog string)
			)
		)
	))
	(setq battleOn (lambda Nil
		(block Nil
			(objAddItem gPlayerShip (itmCreate &bp_itPlasmidGunner; 1) 10)
			(objAddItem gPlayerShip (itmCreate &bp_itMonoFilamentBlade; 1))
		)
	))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Manipulating Player Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	;;;	Player data is kept on the playership because it will change as
	;;; the game progresses.  I have borrowed the dsf helper funcs to 
	;;; minimize redundancy.

	;; This function sets everything up and should only be run once
	(setq bp_InitializePlayerData (lambda Nil
		(if (not (objGetData gPlayerShip "bpInitialized"))
			(block Nil
				(objSetData gPlayerShip "Strength"	10)
				(objSetData gPlayerShip "Defense"	10)
				(objSetData gPlayerShip "HP"		10)
				(objSetData gPlayerShip "C3I"		10)
				(objSetData gPlayerShip "Stealth"	10)
				(objSetData gPlayerShip "Psionic"	10)
				(objSetData gPlayerShip "Hacker"	10)
				(objSetData gPlayerShip "Healer"	10)
				(objSetData gPlayerShip "Demolition" 10)
				(objSetData gPlayerShip "Commando"	10)
				(objSetData gPlayerShip "Commander"	10)

				(objSetData gPlayerShip "Tactics" 	1)
				(objSetData gPlayerShip "bpCommXP" 	0)
				(objSetData gPlayerShip 'bpCommLevel 1)
				(objSetData gPlayerShip 'bpCommPoints 5)
				
				(objSetData gPlayerShip "bpVictories" 0)
				(objSetData gPlayerShip "bpFailures" 0)
				
				(objSetData gPlayership "plyCommitted" Nil)
				
				;; mark that we've been run
				(objSetData gPlayerShip "bpInitialized" True)
			)
		)
	))

	;; If the player has enough xp to gain a level
	;; return the new level, else returns nil
	(setq bp_ComputeCommanderLevel (lambda Nil
		(block (xp oldLvl newLvl)
			(setq xp (objGetData gPlayerShip 'bpCommXP))
			(setq oldLvl (objGetData gPlayerShip 'bpCommLevel))
			(switch
				(leq xp 100)
					(setq newLvl 2)
				(leq xp 250)
					(setq newLvl 3)
				(leq xp 500)
					(setq newLvl 4)
				(leq xp 1000)
					(setq newLvl 5)
				(leq xp 2500)
					(setq newLvl 6)
				(leq xp 5000)
					(setq newLvl 7)
				(leq xp 10000)
					(setq newLvl 8)
				(leq xp 25000)
					(setq newLvl 9)
				(setq newLvl 10)
			)
			(if (gr newLvl oldLvl)
				newLvl
				Nil
			)
		)
	))
	
	;; compute how much xp is needed to achieve the next level and return it
	;; if max level returns 0
	(setq bp_ComputeXPNeeded (lambda Nil
		(block (xp lvl xpNeed)
			(setq xpNeed 0)
			(setq xp (objGetData gPlayerShip 'bpCommXP))
			(setq lvl (objGetData gPlayerShip 'bpCommLevel))
			(switch
				(eq lvl 1)
					(setq xpNeed (subtract 100 xp))
				(eq lvl 2)
					(setq xpNeed (subtract 250 xp))
				(eq lvl 3)
					(setq xpNeed (subtract 500 xp))
				(eq lvl 4)
					(setq xpNeed (subtract 1000 xp))
				(eq lvl 5)
					(setq xpNeed (subtract 2500 xp))
				(eq lvl 6)
					(setq xpNeed (subtract 5000 xp))
				(eq lvl 7)
					(setq xpNeed (subtract 10000 xp))
				(eq lvl 8)
					(setq xpNeed (subtract 25000 xp))
				0
			)
			xpNeed
		)
	))
			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Manipulating Enemy Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Enemy data is kept in static data because it remains the same 
;;; throughout the game and is modified dynamically to suit our needs

	(setq bp_GetEnemyData (lambda (sov stat)
		(block (sovlist data Found)
			(setq sovlist (itmGetStaticData (itmCreate &bp_FactionCalculator; 0) sov))
			(setq Found Nil)
			(enumwhile sovlist (not Found) thisEntry (block Nil
				(if (eq (item thisEntry 0) stat)
					(block nil
						(if (eq stat 'name)
							(setq data (item thisEntry 1))
							(setq data (random (item thisEntry 1) (item thisEntry 2)))
							)
						(setq Found True)
					)
				)
			))
		data
		)
	))
	
	;; Set up an enemy force to fight with
	(setq bp_InitializeEnemy (lambda Nil
		;; check if we've already run
		(if (not (objGetData gSource "initEnemyDone"))
			(block (sov lvl imageData)
				(setq sov (sovHack (objGetSovereign gSource)))
				(setq lvl (sysGetLevel))
				;; we use the image of the station to determine a rough
				;; estimate for how much resistance is present
				(setq imageData (item (objGetImageDesc gSource) 3))
				(switch
					(leq imageData 40)
						(setq imageData '(1 2))
					(leq imageData 75)
						(setq imageData '(1 3))
					(leq imageData 99)
						(setq imageData '(2 5))
					(leq imageData 115)
						(setq imageData '(5 10))
					(leq imageData 130)
						(setq imageData '(10 25))
					(leq imageData 250)
						(setq imageData '(20 50))
					(geq imageData 251)
						(setq imageData '(50 100))
					)
				(objSetData gSource "Name" (bp_GetEnemyData sov 'name))
				(objSetData gSource "strength" (bp_GetEnemyData sov 'Strength))
				(objSetData gSource "defense" (bp_GetEnemyData sov 'Defense))
				(objSetData gSource "hp" (bp_GetEnemyData sov 'HP))
				(objSetData gSource "c3i" (bp_GetEnemyData sov 'C3I))
				(objSetData gSource "stealth" (bp_GetEnemyData sov 'Stealth))
				(objSetData gSource "psionic" (bp_GetEnemyData sov 'Psionic))
				(objSetData gSource "hacker" (bp_GetEnemyData sov 'Hacker))
				(objSetData gSource "healer" (bp_GetEnemyData sov 'Healer))
				(objSetData gSource "demolition" (bp_GetEnemyData sov 'Demolition))
				(objSetData gSource "commando" (bp_GetEnemyData sov 'Commando))
				;; ships have fewer troops then stations so deal with them separately
				(objSetData gSource "enemytroopCount" 
					(if (objIsShip gSource)
						(add (bp_GetEnemyData sov 'Troops) (random 0 (item imageData 0)))
						(add (bp_GetEnemyData sov 'Troops) (random (item imageData 0) (item imageData 1)))
						)
					)
				;; mark that we've been run
				(objSetData gSource "initEnemyDone" True)
				)
			)
	))
			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Core mechanics and logic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	;; this function collects basic player data
	(setq bp_InitializeBattle (lambda Nil
		;; check if we've already run
		(if (not (objGetData gSource "initPlayerDone"))
			(block Nil
				;; collect the data from the player and place it on the spaceObj
				;; we do this because these values will fluctuate and we want to 
				;; preserve the 'base' values stored on the playership
				(objSetData gSource "plyStrength" (objGetData gPlayerShip "Strength"))
				(objSetData gSource "plyDefense" (objGetData gPlayerShip "Defense"))
				(objSetData gSource "plyHP" (objGetData gPlayerShip "HP"))
				(objSetData gSource "plyC3I" (objGetData gPlayerShip "C3I"))
				(objSetData gSource "plyStealth" (objGetData gPlayerShip "Stealth"))
				(objSetData gSource "plyPsionic" (objGetData gPlayerShip "Psionic"))
				(objSetData gSource "plyHacker" (objGetData gPlayerShip "Hacker"))
				(objSetData gSource "plyHealer" (objGetData gPlayerShip "Healer"))
				(objSetData gSource "plyDemolition" (objGetData gPlayerShip "Demolition"))
				(objSetData gSource "plyCommando" (objGetData gPlayerShip "Commando"))
				(objSetData gSource "plyCommander" (objGetData gPlayerShip "Commander"))

				;; initialize some default tactic vars
				(objSetData gSource "tacStrength" 0)
				(objSetData gSource "tacDefense" 0)
				(objSetData gSource "tacHP" 0)
				(objSetData gSource "tacC3I" 0)
				(objSetData gSource "tacStealth" 0)
				(objSetData gSource "tacPsionic" 0)
				(objSetData gSource "tacHacker" 0)
				(objSetData gSource "tacHealer" 0)
				(objSetData gSource "tacDemolition" 0)
				(objSetData gSource "tacCommando" 0)
				;; check the commander's status
				(if (eq (objGetData gPlayership "plyCommitted") True)
					(objSetData gSource "plycommitted" True)
					(objSetData gSource "plyCommitted" Nil)
					)
				;; mark that we've been run
				(objSetData gSource "initPlayerDone" True)
				)
		)
	))
	
	;; init function for the abandoned station dockscreens
	;; it determines if there will be a battle or not
	;; TODO: currently set up to make 100% of wrecks have battles for testing purposes
	(setq intBoardingOnInit (lambda (prevPane)
		(switch
			(eq (objGetData gSource "BattleDone") True)
				Nil ;; continue to normal screen
			(and (leq (objGetDestiny gSource) (multiply (sysGetLevel) 36)))
				(dsf_ShowDockScreen (bp_ScreenData 'Warning))
			Nil ;; we don't qualify for battle, continue normally
				)
		))
		
	;; this function turns sov data into something I can use as a static data element
	(setq sovHack (lambda (sov)
		(switch
			(eq sov 4097)
				'Independent
			(eq sov 4098)
				'Commonwealth
			(or (eq sov 4099) (eq sov 4100))
				'IndMerch
			(eq sov 4101)
				'Charon
			(eq sov 4102)
				'Outlaws
			(eq sov 4103)
				'Ares1
			(eq sov 4104)
				'anarachists
			(eq sov 4105)
				'settlers
			(eq sov 4106)
				'cult
			(eq sov 4107)
				'rogue
			(eq sov 4108)
				'sung
			(eq sov 4109)
				'slaves
			(eq sov 4110)
				'desChaos
			(or (eq sov 4111) (eq sov 4115))
				'auton
			(eq sov 4112)
				'desOrder
			(eq sov 4113)
				'corporate
			(eq sov 4114)
				'BM
			(or (eq sov 4116) (eq sov 4118))
				'ferian
			(eq sov 4117)
				'ringers
			(or (eq sov 1314817) (eq sov -591790014) (eq sov -591790013) (eq sov -591790012))
				'gladiator
			(eq sov 1708033)
				'antarctica
			(eq sov 1708034)
				'CWFleet
			(eq sov 1839105)
				'iocrym
			(eq sov 1839106)
				'Ares2
			(eq sov 1839107)
				'AI
			(eq sov 2101249)
				'domina
			(eq sov 134283333)
				'heliotropes
			(eq sov 134348880)
				'Centauri
			(eq sov 134348932)
				'kobol
			(eq sov 134349003)
				'luminous
			(eq sov 134349058)
				'huari
			(eq sov 134349120)
				'dwarg
			(eq sov 134349133)
				'zoanthropes
			(eq sov 134414409)
				'marauders
			(eq sov 134414594)
				'himal
			(eq sov 134414656)
				'urak
			(eq sov 134480195)
				'gaian
			'misc
			)
		))
)
</Globals>

<!---
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							TACTICS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

The tactical choices will affect the troops in various ways, ranging from
	increasing their attack power or defense to causing damage to the 
	potential loot that is currently being fought for.
the ability to use more advanced tactics will come from fighting more
	battles, and perhaps even some new items.
Choosing a tactic that is appropriate for the troops you are using is
	critical for success.

	Attack
		Required Skill: 0
		success determined by chance,
		no modification of stats
	Retreat
		Required Skill: 0
		Attempt to remove the engaged troops from battle
		success determined by chance,
		Reduce attatck power to 0 and attempt to undock
	Take Cover
		Required Skill: 5
		success determined by chance, healer
		Reduce attack by 25%, raise defense by 50%
	Flank
		Required Skill: 10
		Maintain a superior line of fire
		Success determined by C3I, stealth
		Increase attack by 50%, reduce defense by 25%
	Fighting Withdrawl
		Required Skill: 12
		Maintain line of fire while retreating
		success determined by C3I,
		reduce attack by 50% and attempt to undock
	Feint
		Required Skill: 15
		High chance of caualties on one side or the other
		success determined by C3I, Commando,
		either raise attack by 100% or reduce defense by 50%
	Attrition
		Required Skill: 20
		Maintain cover while slowly retreating
		success determined by 
		raise defense by 25% and attempt to undock
	Rush
		Required Skill: 25
		High chance of casualties on one side or the other
		success determined by chance
		Increase attack by 100% AND reduce defense by 50%
	Siege
		Required Skill: 30
		Use area attacks and long range weaponry
		success determined by demolitions, hacker
		Increase defense by 100%, reduce attack by 50%
	Skirmish
		Required Skill: 35
		Divide and conquer, reduce to one-on-one
		success determined by commando,
		Increase attack by 100%, reduce defense by 50%		
	Ambush
		Required Skill: 40
		Surround the enemy troops
		success determined by hacker, psionics, commando
		Increase attack by 100%
	Spray and Pray
		Required Skill: 45
		Provide cover fire and tend wounds
		success determined by healer, 
		Increase Health back to max
	Assassination
		Required Skill: 50
		Selectively destroy the command structure
		success determined by stealth, hacker, psionics
		Instant victory


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							COMMANDER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

The commander represents the player and a golden opportunity to take the
	game down to the personal level.
The extent to which the commander is used will vary from player to player.
I feel it will be important to provide many options for customization and
	enhancement to really provide an extra element to the gameplay.
	
Just like the troops, the commander will have the 3 basic stats:
	Strength
	Defense
	Health
However, unlike the troops, these stats will begin at a base value and can
	be increased with personal equipment like firearms, armor etc.
This will require many new items that will have limited use and a unique
	method for bringing them into the game may be preferable to the 
	standard looting.  Perhaps awarding them after battle would be better?
These stats will also increase according to level (see below)
	
The commander will also possess the Advanced abilities and these will be 
	included in the battle calculations whether the commander is in
	direct combat or not.
These abilities will increase by level (see below)

The commander will also posses the SKILL attribute a Combat Level and Combat XP.
	A successful battle will award 10XP, a failed battle will award 2XP
	and the levels will be determined as follows:
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							ENEMIES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

It is not in our best interest to create enemy troop items to fight against
	but rather to simply simulate enemy troops.  The enemy will not use
	any tactics, but it would be assumed that when a tactic fails (due to 
	chance or lack of troop ability, commander skill etc.) the enemy was
	responsible.
It may be worthwhile to build a list of sovereigns and each sov have a list
	of target numbers that would be used in the success/failure calculations
	when the player chooses a tactic.
This could provide differentiation between the Sovs/factions, so that the 
	Luminous will be immune to a psionic attack but will be vulnerable to
	hackers.
This data could be stored on a single virtual item in the following format:
	(itmGetStaticData &bp_FactionData; "Luminous") will return:
		(list
			;; base stats
			3	; Strength
			2	; Defense
			1	; Health
			;; adv. ability modifiers (%)
			100	; C3I
			150	; Stealth
			0	; Psionics are useless
			150	; Hacker
			200	; Healer
			100	; Demolitions
			100	; Commando
			;; number of enemy troops
			1d3+2	; number of troops appearing
			)
	where a value of 100 means that the player's ability is unmodified,
	and a value >100 is more effective, <100 is less effective and 0
	is an immunity.
The base stats (ST, DF, and HP) are based on per/troop item values
	and would be summed after calculating the number of troops present 
	from the dice range value.
--->
</TranscendenceExtension>