<?xml version="1.0" ?>
<!DOCTYPE TranscendenceExtension
[
	<!ENTITY BP_Logic				"0xD5125502">
	<!ENTITY bp_FactionCalculator	"0xD5125506">
	<!ENTITY bp_itPlasmidGunner		"0xD5125601">
]>

<TranscendenceExtension UNID="&BP_Logic;" version="1.0">
<Globals>
(block Nil
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Debug functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	;; We'll start with some debug helpers, I have a feeling we'll need them
	;; borrowed from alterecco's DSF mod ;P

	;; This variable controls if we are running in debug or not.
	(setq bp_Debug True)
	;; this is a convenient way to force all debug calls from
	;; log to screen
	(setq bp_DebugToScreen Nil)
	;; DoDebug will print debug information if dsf_Debug
	;; is set. It takes a string which will be output, and
	;; if screen is True, it will be sent to the screen.
	;; Otherwise it will go into the log
	(setq bp_DoDebug (lambda (string screen)
		(if bp_Debug
			(if (or screen bp_DebugToScreen)
				(dbgOutput string)
				(dbgLog string)
			)
		)
	))
	(setq battleOn (lambda Nil
		(block Nil
			(objAddItem gPlayerShip (itmCreate &bp_itPlasmidGunner; 1) 10)
		)
	))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Manipulating Player Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;	Player data is kept on the playership because it will change as
;;; the game progresses.  I have borrowed the dsf helper funcs to 
;;; minimize redundancy.

	;; This function sets everything up and should only be run once
	(setq bp_InitializePlayerData (lambda Nil
		(if (not (objGetData gPlayerShip "bpInitialized"))
			(block Nil
				(objSetData gPlayerShip "Strength"	1)
				(objSetData gPlayerShip "Defense"	1)
				(objSetData gPlayerShip "HP"		1)
				(objSetData gPlayerShip "C3I"		1)
				(objSetData gPlayerShip "Stealth"	1)
				(objSetData gPlayerShip "Psionic"	1)
				(objSetData gPlayerShip "Hacker"	1)
				(objSetData gPlayerShip "Healer"	1)
				(objSetData gPlayerShip "Demolition" 1)
				(objSetData gPlayerShip "Commando"	1)
				(objSetData gPlayerShip "Commander"	1)

				(objSetData gPlayerShip "Tactics" 	1)
				(objSetData gPlayerShip "bpCommXP" 	0)
				(objSetData gPlayerShip "bpCommLevel" 1)
				(objSetData gPlayerShip "bpCommPoints" 5)
				
				(objSetData gPlayerShip "bpVictories" 0)
				(objSetData gPlayerShip "bpFailures" 0)
				
				;; mark that we've been run
				(objSetData gPlayerShip "bpInitialized" True)
			)
		)
	))

	;; If the player has enough xp to gain a level
	;; return the new level, else returns nil
	(setq bp_ComputeCommanderLevel (lambda Nil
		(block (xp oldLvl newLvl)
			(setq xp (dsf_getData 'bpCommXP))
			(setq oldLvl (dsf_GetData 'bpCommLevel))
			(switch
				(leq xp 0)
					(setq newLvl 1)
				(leq xp 100)
					(setq newLvl 2)
				(leq xp 250)
					(setq newLvl 3)
				(leq xp 500)
					(setq newLvl 4)
				(leq xp 1000)
					(setq newLvl 5)
				(leq xp 2500)
					(setq newLvl 6)
				(leq xp 5000)
					(setq newLvl 7)
				(leq xp 10000)
					(setq newLvl 8)
				(leq xp 25000)
					(setq newLvl 9)
				(setq newLvl 10)
			)
			(if (gr newLvl oldLvl)
				newLvl
				Nil
			)
		)
	))
	
	;; compute how much xp is needed to achieve the next level and return it
	;; if max level returns 0
	(setq bp_ComputeXPNeeded (lambda Nil
		(block (xp lvl xpNeed)
			(setq xp (dsf_GetData 'bpCommXP))
			(setq lvl (dsf_GetData 'bpCommLvl))
			(switch
				(eq lvl 1)
					(setq xpNeed (subtract xp 100))
				(eq lvl 2)
					(setq xpNeed (subtract xp 250))
				(eq lvl 3)
					(setq xpNeed (subtract xp 500))
				(eq lvl 4)
					(setq xpNeed (subtract xp 1000))
				(eq lvl 5)
					(setq xpNeed (subtract xp 2500))
				(eq lvl 6)
					(setq xpNeed (subtract xp 5000))
				(eq lvl 7)
					(setq xpNeed (subtract xp 10000))
				(eq lvl 8)
					(setq xpNeed (subtract xp 25000))
				0
			)
			xpNeed
		)
	))
			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Manipulating Enemy Data
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Enemy data is kept in static data because it remains the same 
;;; throughout the game and is modified dynamically to suit our needs

	(setq bp_GetEnemyData (lambda (sov stat)
		(block (list data Found)
			(setq list (itmGetStaticData &bp_FactionCalculator; sov))
			(setq Found Nil)
			(enumwhile list (not Found) thisEntry (block Nil
				(if (eq (item thisEntry 0) stat)
					(block nil
						(setq data (item thisEntry 1))
						(setq Found True)
					)
				)
			))
		data
		)
	))
	(setq bp_GetEnemyTroopCount (lambda (sov)
		(block (list data Found)
			(setq list (itmGetStaticData &bp_FactionCalculator; sov))
			(setq Found Nil)
			(enumwhile list (not Found) thisEntry (block Nil
				(if (eq (item thisEntry 0) stat)
					(block nil
						(setq min (item thisEntry 1))
						(setq max (item thisEntry 2))
						(setq data (random min max))
						(setq Found True)
					)
				)
			))
		data
		)
	))
	
	;; Set up an enemy force to fight with
	(setq bp_InitializeEnemy (lambda Nil
		(block (sov lvl)
			(setq sov (typGetDataField (objGetSovereign gSource) 'name))
			(setq lvl (sysGetLevel))
			(objSetData gSource "str" (bp_GetEnemyData sov 'Strength))
			(objSetData gSource "def" (bp_GetEnemyData sov 'Defense))
			(objSetData gSource "hp" (bp_GetEnemyData sov 'HP))
			(objSetData gSource "c3i" (bp_GetEnemyData sov 'C3I))
			(objSetData gSource "stl" (bp_GetEnemyData sov 'Stealth))
			(objSetData gSource "psi" (bp_GetEnemyData sov 'Psionic))
			(objSetData gSource "hack" (bp_GetEnemyData sov 'Hacker))
			(objSetData gSource "heal" (bp_GetEnemyData sov 'Healer))
			(objSetData gSource "dem" (bp_GetEnemyData sov 'Demolition))
			(objSetData gSource "como" (bp_GetEnemyData sov 'Commando))
			(objSetData gSource "num" (bp_GetEnemyTroopCount sov 'Troops))
		)
	))
			
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;		Core mechanics and logic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	;; this function collects basic player data to determine how much
	;; info is presented at the beginning of combat
	(setq bp_InitializeBattle (lambda Nil
		(block Nil
		)
	))
)
</Globals>

<!---
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							TACTICS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

The tactical choices will affect the troops in various ways, ranging from
	increasing their attack power or defense to causing damage to the 
	potential loot that is currently being fought for.
the ability to use more advanced tactics will come from fighting more
	battles, and perhaps even some new items.
Choosing a tactic that is appropriate for the troops you are using is
	critical for success.

	Attack
		Required Skill: 0
		success determined by chance,
		no modification of stats
	Retreat
		Required Skill: 0
		Attempt to remove the engaged troops from battle
		success determined by chance,
		Reduce attatck power to 0 and attempt to undock
	Take Cover
		Required Skill: 5
		success determined by chance, healer
		Reduce attack by 25%, raise defense by 50%
	Flank
		Required Skill: 10
		Maintain a superior line of fire
		Success determined by C3I, stealth
		Increase attack by 50%, reduce defense by 25%
	Fighting Withdrawl
		Required Skill: 12
		Maintain line of fire while retreating
		success determined by C3I,
		reduce attack by 50% and attempt to undock
	Feint
		Required Skill: 15
		High chance of caualties on one side or the other
		success determined by C3I, Commando,
		either raise attack by 100% or reduce defense by 50%
	Attrition
		Required Skill: 20
		Maintain cover while slowly retreating
		success determined by 
		raise defense by 25% and attempt to undock
	Rush
		Required Skill: 25
		High chance of casualties on one side or the other
		success determined by chance
		Increase attack by 100% AND reduce defense by 50%
	Siege
		Required Skill: 30
		Use area attacks and long range weaponry
		success determined by demolitions, hacker
		Increase defense by 100%, reduce attack by 50%
	Skirmish
		Required Skill: 35
		Divide and conquer, reduce to one-on-one
		success determined by commando,
		Increase attack by 100%, reduce defense by 50%		
	Ambush
		Required Skill: 40
		Surround the enemy troops
		success determined by hacker, psionics, commando
		Increase attack by 100%
	Spray and Pray
		Required Skill: 45
		Provide cover fire and tend wounds
		success determined by healer, 
		Increase Health back to max
	Assassination
		Required Skill: 50
		Selectively destroy the command structure
		success determined by stealth, hacker, psionics
		Instant victory


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							COMMANDER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

The commander represents the player and a golden opportunity to take the
	game down to the personal level.
The extent to which the commander is used will vary from player to player.
I feel it will be important to provide many options for customization and
	enhancement to really provide an extra element to the gameplay.
	
Just like the troops, the commander will have the 3 basic stats:
	Strength
	Defense
	Health
However, unlike the troops, these stats will begin at a base value and can
	be increased with personal equipment like firearms, armor etc.
This will require many new items that will have limited use and a unique
	method for bringing them into the game may be preferable to the 
	standard looting.  Perhaps awarding them after battle would be better?
These stats will also increase according to level (see below)
	
The commander will also possess the Advanced abilities and these will be 
	included in the battle calculations whether the commander is in
	direct combat or not.
These abilities will increase by level (see below)

The commander will also posses the SKILL attribute a Combat Level and Combat XP.
	A successful battle will award 10XP, a failed battle will award 2XP
	and the levels will be determined as follows:
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;							ENEMIES
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

It is not in our best interest to create enemy troop items to fight against
	but rather to simply simulate enemy troops.  The enemy will not use
	any tactics, but it would be assumed that when a tactic fails (due to 
	chance or lack of troop ability, commander skill etc.) the enemy was
	responsible.
It may be worthwhile to build a list of sovereigns and each sov have a list
	of target numbers that would be used in the success/failure calculations
	when the player chooses a tactic.
This could provide differentiation between the Sovs/factions, so that the 
	Luminous will be immune to a psionic attack but will be vulnerable to
	hackers.
This data could be stored on a single virtual item in the following format:
	(itmGetStaticData &bp_FactionData; "Luminous") will return:
		(list
			;; base stats
			3	; Strength
			2	; Defense
			1	; Health
			;; adv. ability modifiers (%)
			100	; C3I
			150	; Stealth
			0	; Psionics are useless
			150	; Hacker
			200	; Healer
			100	; Demolitions
			100	; Commando
			;; number of enemy troops
			1d3+2	; number of troops appearing
			)
	where a value of 100 means that the player's ability is unmodified,
	and a value >100 is more effective, <100 is less effective and 0
	is an immunity.
The base stats (ST, DF, and HP) are based on per/troop item values
	and would be summed after calculating the number of troops present 
	from the dice range value.
--->
</TranscendenceExtension>
